//
// Generated by Bluespec Compiler, version 2009.10.B (build 18070, 2009-10-11)
//
// On Thu Nov 19 16:26:19 BRST 2009
//
// Method conflict info:
// Method: pegar_valor
// Conflict-free: pegar_valor
//
//
// Ports:
// Name                         I/O  size props
// pegar_valor                    O    32 reg
// RDY_pegar_valor                O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkMaxValue(CLK,
		  RST_N,

		  pegar_valor,
		  RDY_pegar_valor);
  input  CLK;
  input  RST_N;

  // value method pegar_valor
  output [31 : 0] pegar_valor;
  output RDY_pegar_valor;

  // signals for module outputs
  wire [31 : 0] pegar_valor;
  wire RDY_pegar_valor;

  // inlined wires
  wire ram_serverAdapterA_outData_deqCalled$whas,
       ram_serverAdapterA_outData_enqData$whas,
       ram_serverAdapterA_outData_outData$whas,
       ram_serverAdapterB_outData_enqData$whas,
       ram_serverAdapterB_outData_outData$whas;

  // register current_addr
  reg [10 : 0] current_addr;
  wire [10 : 0] current_addr$D_IN;
  wire current_addr$EN;

  // register maior_valor
  reg [31 : 0] maior_valor;
  wire [31 : 0] maior_valor$D_IN;
  wire maior_valor$EN;

  // register ram_serverAdapterA_cnt
  reg [2 : 0] ram_serverAdapterA_cnt;
  wire [2 : 0] ram_serverAdapterA_cnt$D_IN;
  wire ram_serverAdapterA_cnt$EN;

  // register ram_serverAdapterA_s1
  reg [1 : 0] ram_serverAdapterA_s1;
  wire [1 : 0] ram_serverAdapterA_s1$D_IN;
  wire ram_serverAdapterA_s1$EN;

  // register ram_serverAdapterB_cnt
  reg [2 : 0] ram_serverAdapterB_cnt;
  wire [2 : 0] ram_serverAdapterB_cnt$D_IN;
  wire ram_serverAdapterB_cnt$EN;

  // register ram_serverAdapterB_s1
  reg [1 : 0] ram_serverAdapterB_s1;
  wire [1 : 0] ram_serverAdapterB_s1$D_IN;
  wire ram_serverAdapterB_s1$EN;

  // ports of submodule ram_memory
  wire [31 : 0] ram_memory$DIA,
		ram_memory$DIB,
		ram_memory$DOA,
		ram_memory$DOB;
  wire [10 : 0] ram_memory$ADDRA, ram_memory$ADDRB;
  wire ram_memory$ENA, ram_memory$ENB, ram_memory$WEA, ram_memory$WEB;

  // ports of submodule ram_serverAdapterA_outDataCore
  wire [31 : 0] ram_serverAdapterA_outDataCore$D_IN,
		ram_serverAdapterA_outDataCore$D_OUT;
  wire ram_serverAdapterA_outDataCore$CLR,
       ram_serverAdapterA_outDataCore$DEQ,
       ram_serverAdapterA_outDataCore$EMPTY_N,
       ram_serverAdapterA_outDataCore$ENQ,
       ram_serverAdapterA_outDataCore$FULL_N;

  // ports of submodule ram_serverAdapterB_outDataCore
  wire [31 : 0] ram_serverAdapterB_outDataCore$D_IN,
		ram_serverAdapterB_outDataCore$D_OUT;
  wire ram_serverAdapterB_outDataCore$CLR,
       ram_serverAdapterB_outDataCore$DEQ,
       ram_serverAdapterB_outDataCore$EMPTY_N,
       ram_serverAdapterB_outDataCore$ENQ,
       ram_serverAdapterB_outDataCore$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_ram_serverAdapterA_outData_enqAndDeq,
       WILL_FIRE_RL_ram_serverAdapterA_outData_setFirstEnq,
       WILL_FIRE_RL_ram_serverAdapterB_outData_enqAndDeq,
       WILL_FIRE_RL_ram_serverAdapterB_outData_setFirstEnq,
       WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways;

  // remaining internal signals
  wire [31 : 0] _theResult____h3318, v__h3118, v__h3218;
  wire [2 : 0] ram_serverAdapterA_cnt_9_PLUS_IF_ram_serverAda_ETC___d119,
	       ram_serverAdapterB_cnt_1_PLUS_IF_ram_serverAda_ETC___d65;

  // value method pegar_valor
  assign pegar_valor = maior_valor ;
  assign RDY_pegar_valor = current_addr == 11'd2047 ;

  // submodule ram_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd11),
	  .DATA_WIDTH(32'd32),
	  .MEMSIZE(12'd2048)) ram_memory(.CLKA(CLK),
					 .CLKB(CLK),
					 .ADDRA(ram_memory$ADDRA),
					 .ADDRB(ram_memory$ADDRB),
					 .DIA(ram_memory$DIA),
					 .DIB(ram_memory$DIB),
					 .WEA(ram_memory$WEA),
					 .WEB(ram_memory$WEB),
					 .ENA(ram_memory$ENA),
					 .ENB(ram_memory$ENB),
					 .DOA(ram_memory$DOA),
					 .DOB(ram_memory$DOB));

  // submodule ram_serverAdapterA_outDataCore
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) ram_serverAdapterA_outDataCore(.RST_N(RST_N),
							      .CLK(CLK),
							      .D_IN(ram_serverAdapterA_outDataCore$D_IN),
							      .ENQ(ram_serverAdapterA_outDataCore$ENQ),
							      .DEQ(ram_serverAdapterA_outDataCore$DEQ),
							      .CLR(ram_serverAdapterA_outDataCore$CLR),
							      .D_OUT(ram_serverAdapterA_outDataCore$D_OUT),
							      .FULL_N(ram_serverAdapterA_outDataCore$FULL_N),
							      .EMPTY_N(ram_serverAdapterA_outDataCore$EMPTY_N));

  // submodule ram_serverAdapterB_outDataCore
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) ram_serverAdapterB_outDataCore(.RST_N(RST_N),
							      .CLK(CLK),
							      .D_IN(ram_serverAdapterB_outDataCore$D_IN),
							      .ENQ(ram_serverAdapterB_outDataCore$ENQ),
							      .DEQ(ram_serverAdapterB_outDataCore$DEQ),
							      .CLR(ram_serverAdapterB_outDataCore$CLR),
							      .D_OUT(ram_serverAdapterB_outDataCore$D_OUT),
							      .FULL_N(ram_serverAdapterB_outDataCore$FULL_N),
							      .EMPTY_N(ram_serverAdapterB_outDataCore$EMPTY_N));

  // rule RL_ram_serverAdapterB_stageReadResponseAlways
  assign WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways =
	     (ram_serverAdapterA_cnt ^ 3'h4) < 3'd7 &&
	     (ram_serverAdapterB_cnt ^ 3'h4) < 3'd7 &&
	     current_addr != 11'd2047 ;

  // rule RL_ram_serverAdapterB_outData_setFirstEnq
  assign WILL_FIRE_RL_ram_serverAdapterB_outData_setFirstEnq =
	     !ram_serverAdapterB_outDataCore$EMPTY_N &&
	     ram_serverAdapterB_outData_enqData$whas ;

  // rule RL_ram_serverAdapterA_outData_setFirstEnq
  assign WILL_FIRE_RL_ram_serverAdapterA_outData_setFirstEnq =
	     !ram_serverAdapterA_outDataCore$EMPTY_N &&
	     ram_serverAdapterA_outData_enqData$whas ;

  // rule RL_ram_serverAdapterB_outData_enqAndDeq
  assign WILL_FIRE_RL_ram_serverAdapterB_outData_enqAndDeq =
	     ram_serverAdapterB_outDataCore$FULL_N &&
	     ram_serverAdapterB_outDataCore$EMPTY_N &&
	     ram_serverAdapterA_outData_deqCalled$whas &&
	     ram_serverAdapterB_outData_enqData$whas ;

  // rule RL_ram_serverAdapterA_outData_enqAndDeq
  assign WILL_FIRE_RL_ram_serverAdapterA_outData_enqAndDeq =
	     ram_serverAdapterA_outDataCore$FULL_N &&
	     ram_serverAdapterA_outDataCore$EMPTY_N &&
	     ram_serverAdapterA_outData_deqCalled$whas &&
	     ram_serverAdapterA_outData_enqData$whas ;

  // inlined wires
  assign ram_serverAdapterA_outData_enqData$whas =
	     ram_serverAdapterA_outDataCore$FULL_N &&
	     ram_serverAdapterA_s1[1] &&
	     ram_serverAdapterA_s1[0] ;
  assign ram_serverAdapterA_outData_outData$whas =
	     WILL_FIRE_RL_ram_serverAdapterA_outData_setFirstEnq ||
	     ram_serverAdapterA_outDataCore$EMPTY_N ;
  assign ram_serverAdapterB_outData_enqData$whas =
	     ram_serverAdapterB_outDataCore$FULL_N &&
	     ram_serverAdapterB_s1[1] &&
	     ram_serverAdapterB_s1[0] ;
  assign ram_serverAdapterB_outData_outData$whas =
	     WILL_FIRE_RL_ram_serverAdapterB_outData_setFirstEnq ||
	     ram_serverAdapterB_outDataCore$EMPTY_N ;
  assign ram_serverAdapterA_outData_deqCalled$whas =
	     (ram_serverAdapterA_outDataCore$EMPTY_N ||
	      ram_serverAdapterA_outData_enqData$whas) &&
	     ram_serverAdapterA_outData_outData$whas &&
	     (ram_serverAdapterB_outDataCore$EMPTY_N ||
	      ram_serverAdapterB_outData_enqData$whas) &&
	     ram_serverAdapterB_outData_outData$whas ;

  // register current_addr
  assign current_addr$D_IN = current_addr + 11'd2 ;
  assign current_addr$EN =
	     WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ;

  // register maior_valor
  assign maior_valor$D_IN =
	     (v__h3218 <= _theResult____h3318) ?
	       _theResult____h3318 :
	       v__h3218 ;
  assign maior_valor$EN = ram_serverAdapterA_outData_deqCalled$whas ;

  // register ram_serverAdapterA_cnt
  assign ram_serverAdapterA_cnt$D_IN =
	     ram_serverAdapterA_cnt_9_PLUS_IF_ram_serverAda_ETC___d119 ;
  assign ram_serverAdapterA_cnt$EN =
	     WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ||
	     ram_serverAdapterA_outData_deqCalled$whas ;

  // register ram_serverAdapterA_s1
  assign ram_serverAdapterA_s1$D_IN =
	     { WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways,
	       1'b1 } ;
  assign ram_serverAdapterA_s1$EN = 1'd1 ;

  // register ram_serverAdapterB_cnt
  assign ram_serverAdapterB_cnt$D_IN =
	     ram_serverAdapterB_cnt_1_PLUS_IF_ram_serverAda_ETC___d65 ;
  assign ram_serverAdapterB_cnt$EN =
	     WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ||
	     ram_serverAdapterA_outData_deqCalled$whas ;

  // register ram_serverAdapterB_s1
  assign ram_serverAdapterB_s1$D_IN =
	     { WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways,
	       1'b1 } ;
  assign ram_serverAdapterB_s1$EN = 1'd1 ;

  // submodule ram_memory
  assign ram_memory$WEA = 1'd0 ;
  assign ram_memory$ADDRA = current_addr ;
  assign ram_memory$WEB = 1'd0 ;
  assign ram_memory$DIA = 32'hAAAAAAAA /* unspecified value */  ;
  assign ram_memory$ADDRB = current_addr + 11'd1 ;
  assign ram_memory$DIB = 32'hAAAAAAAA /* unspecified value */  ;
  assign ram_memory$ENA =
	     WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ;
  assign ram_memory$ENB =
	     WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ;

  // submodule ram_serverAdapterA_outDataCore
  assign ram_serverAdapterA_outDataCore$D_IN = ram_memory$DOA ;
  assign ram_serverAdapterA_outDataCore$ENQ =
	     ram_serverAdapterA_outDataCore$FULL_N &&
	     !ram_serverAdapterA_outData_deqCalled$whas &&
	     ram_serverAdapterA_outData_enqData$whas ||
	     WILL_FIRE_RL_ram_serverAdapterA_outData_enqAndDeq ;
  assign ram_serverAdapterA_outDataCore$DEQ =
	     ram_serverAdapterA_outDataCore$EMPTY_N &&
	     ram_serverAdapterA_outData_deqCalled$whas &&
	     !ram_serverAdapterA_outData_enqData$whas ||
	     WILL_FIRE_RL_ram_serverAdapterA_outData_enqAndDeq ;
  assign ram_serverAdapterA_outDataCore$CLR = 1'b0 ;

  // submodule ram_serverAdapterB_outDataCore
  assign ram_serverAdapterB_outDataCore$D_IN = ram_memory$DOB ;
  assign ram_serverAdapterB_outDataCore$DEQ =
	     ram_serverAdapterB_outDataCore$EMPTY_N &&
	     ram_serverAdapterA_outData_deqCalled$whas &&
	     !ram_serverAdapterB_outData_enqData$whas ||
	     WILL_FIRE_RL_ram_serverAdapterB_outData_enqAndDeq ;
  assign ram_serverAdapterB_outDataCore$ENQ =
	     ram_serverAdapterB_outDataCore$FULL_N &&
	     !ram_serverAdapterA_outData_deqCalled$whas &&
	     ram_serverAdapterB_outData_enqData$whas ||
	     WILL_FIRE_RL_ram_serverAdapterB_outData_enqAndDeq ;
  assign ram_serverAdapterB_outDataCore$CLR = 1'b0 ;

  // remaining internal signals
  assign _theResult____h3318 =
	     (v__h3118 <= maior_valor) ? maior_valor : v__h3118 ;
  assign ram_serverAdapterA_cnt_9_PLUS_IF_ram_serverAda_ETC___d119 =
	     ram_serverAdapterA_cnt +
	     (WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ?
		3'd1 :
		3'd0) +
	     (ram_serverAdapterA_outData_deqCalled$whas ? 3'd7 : 3'd0) ;
  assign ram_serverAdapterB_cnt_1_PLUS_IF_ram_serverAda_ETC___d65 =
	     ram_serverAdapterB_cnt +
	     (WILL_FIRE_RL_ram_serverAdapterB_stageReadResponseAlways ?
		3'd1 :
		3'd0) +
	     (ram_serverAdapterA_outData_deqCalled$whas ? 3'd7 : 3'd0) ;
  assign v__h3118 =
	     WILL_FIRE_RL_ram_serverAdapterA_outData_setFirstEnq ?
	       ram_memory$DOA :
	       ram_serverAdapterA_outDataCore$D_OUT ;
  assign v__h3218 =
	     WILL_FIRE_RL_ram_serverAdapterB_outData_setFirstEnq ?
	       ram_memory$DOB :
	       ram_serverAdapterB_outDataCore$D_OUT ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        current_addr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	maior_valor <= `BSV_ASSIGNMENT_DELAY 32'd0;
	ram_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	ram_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	ram_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	ram_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (current_addr$EN)
	  current_addr <= `BSV_ASSIGNMENT_DELAY current_addr$D_IN;
	if (maior_valor$EN)
	  maior_valor <= `BSV_ASSIGNMENT_DELAY maior_valor$D_IN;
	if (ram_serverAdapterA_cnt$EN)
	  ram_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY
	      ram_serverAdapterA_cnt$D_IN;
	if (ram_serverAdapterA_s1$EN)
	  ram_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY
	      ram_serverAdapterA_s1$D_IN;
	if (ram_serverAdapterB_cnt$EN)
	  ram_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY
	      ram_serverAdapterB_cnt$D_IN;
	if (ram_serverAdapterB_s1$EN)
	  ram_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY
	      ram_serverAdapterB_s1$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    current_addr = 11'h2AA;
    maior_valor = 32'hAAAAAAAA;
    ram_serverAdapterA_cnt = 3'h2;
    ram_serverAdapterA_s1 = 2'h2;
    ram_serverAdapterB_cnt = 3'h2;
    ram_serverAdapterB_s1 = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (ram_serverAdapterB_s1[1] && !ram_serverAdapterB_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N)
      if (ram_serverAdapterA_s1[1] && !ram_serverAdapterA_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
  end
  // synopsys translate_on
endmodule  // mkMaxValue

